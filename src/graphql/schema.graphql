# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"columns and relationships of \"food\""
type food {
    A: numeric
    B1: numeric
    B12: numeric
    B2: numeric
    B3: numeric
    B5: numeric
    B6: numeric
    B7: numeric
    B9: numeric
    C: numeric
    D: numeric
    E: numeric
    K: numeric
    calcium: numeric
    carbohydrates: numeric!
    carbohydrates_fiber: numeric
    carbohydrates_starch: numeric
    carbohydrates_sugars: numeric
    copper: numeric
    energy_cal: numeric!
    energy_kj: numeric!
    fats: numeric!
    "An object relationship"
    food_type: food_type!
    id: uuid!
    iron: numeric
    magnesium: numeric
    manganese: numeric
    "An array relationship"
    meal_items(
        "distinct select on columns"
        distinct_on: [meal_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_item_order_by!],
        "filter the rows returned"
        where: meal_item_bool_exp
    ): [meal_item!]!
    "An aggregated array relationship"
    meal_items_aggregate(
        "distinct select on columns"
        distinct_on: [meal_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_item_order_by!],
        "filter the rows returned"
        where: meal_item_bool_exp
    ): meal_item_aggregate!
    name: bpchar!
    phosphorus: numeric
    potassium: numeric
    proteins: numeric!
    selenium: numeric
    sodium: numeric
    type: String!
    weight: Int
    zinc: numeric
}

"aggregated selection of \"food\""
type food_aggregate {
    aggregate: food_aggregate_fields
    nodes: [food!]!
}

"aggregate fields of \"food\""
type food_aggregate_fields {
    avg: food_avg_fields
    count(columns: [food_select_column!], distinct: Boolean): Int
    max: food_max_fields
    min: food_min_fields
    stddev: food_stddev_fields
    stddev_pop: food_stddev_pop_fields
    stddev_samp: food_stddev_samp_fields
    sum: food_sum_fields
    var_pop: food_var_pop_fields
    var_samp: food_var_samp_fields
    variance: food_variance_fields
}

"aggregate avg on columns"
type food_avg_fields {
    A: Float
    B1: Float
    B12: Float
    B2: Float
    B3: Float
    B5: Float
    B6: Float
    B7: Float
    B9: Float
    C: Float
    D: Float
    E: Float
    K: Float
    calcium: Float
    carbohydrates: Float
    carbohydrates_fiber: Float
    carbohydrates_starch: Float
    carbohydrates_sugars: Float
    copper: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    iron: Float
    magnesium: Float
    manganese: Float
    phosphorus: Float
    potassium: Float
    proteins: Float
    selenium: Float
    sodium: Float
    weight: Float
    zinc: Float
}

"aggregate max on columns"
type food_max_fields {
    A: numeric
    B1: numeric
    B12: numeric
    B2: numeric
    B3: numeric
    B5: numeric
    B6: numeric
    B7: numeric
    B9: numeric
    C: numeric
    D: numeric
    E: numeric
    K: numeric
    calcium: numeric
    carbohydrates: numeric
    carbohydrates_fiber: numeric
    carbohydrates_starch: numeric
    carbohydrates_sugars: numeric
    copper: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    id: uuid
    iron: numeric
    magnesium: numeric
    manganese: numeric
    phosphorus: numeric
    potassium: numeric
    proteins: numeric
    selenium: numeric
    sodium: numeric
    type: String
    weight: Int
    zinc: numeric
}

"aggregate min on columns"
type food_min_fields {
    A: numeric
    B1: numeric
    B12: numeric
    B2: numeric
    B3: numeric
    B5: numeric
    B6: numeric
    B7: numeric
    B9: numeric
    C: numeric
    D: numeric
    E: numeric
    K: numeric
    calcium: numeric
    carbohydrates: numeric
    carbohydrates_fiber: numeric
    carbohydrates_starch: numeric
    carbohydrates_sugars: numeric
    copper: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    id: uuid
    iron: numeric
    magnesium: numeric
    manganese: numeric
    phosphorus: numeric
    potassium: numeric
    proteins: numeric
    selenium: numeric
    sodium: numeric
    type: String
    weight: Int
    zinc: numeric
}

"response of any mutation on the table \"food\""
type food_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [food!]!
}

"aggregate stddev on columns"
type food_stddev_fields {
    A: Float
    B1: Float
    B12: Float
    B2: Float
    B3: Float
    B5: Float
    B6: Float
    B7: Float
    B9: Float
    C: Float
    D: Float
    E: Float
    K: Float
    calcium: Float
    carbohydrates: Float
    carbohydrates_fiber: Float
    carbohydrates_starch: Float
    carbohydrates_sugars: Float
    copper: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    iron: Float
    magnesium: Float
    manganese: Float
    phosphorus: Float
    potassium: Float
    proteins: Float
    selenium: Float
    sodium: Float
    weight: Float
    zinc: Float
}

"aggregate stddev_pop on columns"
type food_stddev_pop_fields {
    A: Float
    B1: Float
    B12: Float
    B2: Float
    B3: Float
    B5: Float
    B6: Float
    B7: Float
    B9: Float
    C: Float
    D: Float
    E: Float
    K: Float
    calcium: Float
    carbohydrates: Float
    carbohydrates_fiber: Float
    carbohydrates_starch: Float
    carbohydrates_sugars: Float
    copper: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    iron: Float
    magnesium: Float
    manganese: Float
    phosphorus: Float
    potassium: Float
    proteins: Float
    selenium: Float
    sodium: Float
    weight: Float
    zinc: Float
}

"aggregate stddev_samp on columns"
type food_stddev_samp_fields {
    A: Float
    B1: Float
    B12: Float
    B2: Float
    B3: Float
    B5: Float
    B6: Float
    B7: Float
    B9: Float
    C: Float
    D: Float
    E: Float
    K: Float
    calcium: Float
    carbohydrates: Float
    carbohydrates_fiber: Float
    carbohydrates_starch: Float
    carbohydrates_sugars: Float
    copper: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    iron: Float
    magnesium: Float
    manganese: Float
    phosphorus: Float
    potassium: Float
    proteins: Float
    selenium: Float
    sodium: Float
    weight: Float
    zinc: Float
}

"aggregate sum on columns"
type food_sum_fields {
    A: numeric
    B1: numeric
    B12: numeric
    B2: numeric
    B3: numeric
    B5: numeric
    B6: numeric
    B7: numeric
    B9: numeric
    C: numeric
    D: numeric
    E: numeric
    K: numeric
    calcium: numeric
    carbohydrates: numeric
    carbohydrates_fiber: numeric
    carbohydrates_starch: numeric
    carbohydrates_sugars: numeric
    copper: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    iron: numeric
    magnesium: numeric
    manganese: numeric
    phosphorus: numeric
    potassium: numeric
    proteins: numeric
    selenium: numeric
    sodium: numeric
    weight: Int
    zinc: numeric
}

"columns and relationships of \"food_type\""
type food_type {
    decription: String!
    "An array relationship"
    food(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): [food!]!
    "An aggregated array relationship"
    food_aggregate(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): food_aggregate!
    value: String!
}

"aggregated selection of \"food_type\""
type food_type_aggregate {
    aggregate: food_type_aggregate_fields
    nodes: [food_type!]!
}

"aggregate fields of \"food_type\""
type food_type_aggregate_fields {
    count(columns: [food_type_select_column!], distinct: Boolean): Int
    max: food_type_max_fields
    min: food_type_min_fields
}

"aggregate max on columns"
type food_type_max_fields {
    decription: String
    value: String
}

"aggregate min on columns"
type food_type_min_fields {
    decription: String
    value: String
}

"response of any mutation on the table \"food_type\""
type food_type_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [food_type!]!
}

"aggregate var_pop on columns"
type food_var_pop_fields {
    A: Float
    B1: Float
    B12: Float
    B2: Float
    B3: Float
    B5: Float
    B6: Float
    B7: Float
    B9: Float
    C: Float
    D: Float
    E: Float
    K: Float
    calcium: Float
    carbohydrates: Float
    carbohydrates_fiber: Float
    carbohydrates_starch: Float
    carbohydrates_sugars: Float
    copper: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    iron: Float
    magnesium: Float
    manganese: Float
    phosphorus: Float
    potassium: Float
    proteins: Float
    selenium: Float
    sodium: Float
    weight: Float
    zinc: Float
}

"aggregate var_samp on columns"
type food_var_samp_fields {
    A: Float
    B1: Float
    B12: Float
    B2: Float
    B3: Float
    B5: Float
    B6: Float
    B7: Float
    B9: Float
    C: Float
    D: Float
    E: Float
    K: Float
    calcium: Float
    carbohydrates: Float
    carbohydrates_fiber: Float
    carbohydrates_starch: Float
    carbohydrates_sugars: Float
    copper: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    iron: Float
    magnesium: Float
    manganese: Float
    phosphorus: Float
    potassium: Float
    proteins: Float
    selenium: Float
    sodium: Float
    weight: Float
    zinc: Float
}

"aggregate variance on columns"
type food_variance_fields {
    A: Float
    B1: Float
    B12: Float
    B2: Float
    B3: Float
    B5: Float
    B6: Float
    B7: Float
    B9: Float
    C: Float
    D: Float
    E: Float
    K: Float
    calcium: Float
    carbohydrates: Float
    carbohydrates_fiber: Float
    carbohydrates_starch: Float
    carbohydrates_sugars: Float
    copper: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    iron: Float
    magnesium: Float
    manganese: Float
    phosphorus: Float
    potassium: Float
    proteins: Float
    selenium: Float
    sodium: Float
    weight: Float
    zinc: Float
}

"columns and relationships of \"meal\""
type meal {
    date: date
    id: uuid!
    "An array relationship"
    meal_items(
        "distinct select on columns"
        distinct_on: [meal_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_item_order_by!],
        "filter the rows returned"
        where: meal_item_bool_exp
    ): [meal_item!]!
    "An aggregated array relationship"
    meal_items_aggregate(
        "distinct select on columns"
        distinct_on: [meal_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_item_order_by!],
        "filter the rows returned"
        where: meal_item_bool_exp
    ): meal_item_aggregate!
    name: String
    time: time
    u_id: uuid
    "An object relationship"
    user: users
}

"aggregated selection of \"meal\""
type meal_aggregate {
    aggregate: meal_aggregate_fields
    nodes: [meal!]!
}

"aggregate fields of \"meal\""
type meal_aggregate_fields {
    count(columns: [meal_select_column!], distinct: Boolean): Int
    max: meal_max_fields
    min: meal_min_fields
}

"columns and relationships of \"meal_item\""
type meal_item {
    "Calculation of a macronutrient according to weight"
    carbohydrates: numeric!
    "Calculation of an energy according to weight"
    energy_cal: numeric!
    "Calculation of a macronutrient according to weight"
    energy_kj: numeric!
    "Calculation of a macronutrient according to weight"
    fats: numeric!
    food: uuid
    "An object relationship"
    foodDesc: food
    id: uuid!
    "An object relationship"
    meal: meal!
    meal_id: uuid!
    "Calculation of a macronutrient according to weight"
    proteins: numeric!
    "An object relationship"
    recipe: recipe
    recipe_id: uuid
    u_id: uuid!
    "An object relationship"
    user: users!
    weight: numeric!
}

"aggregated selection of \"meal_item\""
type meal_item_aggregate {
    aggregate: meal_item_aggregate_fields
    nodes: [meal_item!]!
}

"aggregate fields of \"meal_item\""
type meal_item_aggregate_fields {
    avg: meal_item_avg_fields
    count(columns: [meal_item_select_column!], distinct: Boolean): Int
    max: meal_item_max_fields
    min: meal_item_min_fields
    stddev: meal_item_stddev_fields
    stddev_pop: meal_item_stddev_pop_fields
    stddev_samp: meal_item_stddev_samp_fields
    sum: meal_item_sum_fields
    var_pop: meal_item_var_pop_fields
    var_samp: meal_item_var_samp_fields
    variance: meal_item_variance_fields
}

"aggregate avg on columns"
type meal_item_avg_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate max on columns"
type meal_item_max_fields {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food: uuid
    id: uuid
    meal_id: uuid
    proteins: numeric
    recipe_id: uuid
    u_id: uuid
    weight: numeric
}

"aggregate min on columns"
type meal_item_min_fields {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food: uuid
    id: uuid
    meal_id: uuid
    proteins: numeric
    recipe_id: uuid
    u_id: uuid
    weight: numeric
}

"response of any mutation on the table \"meal_item\""
type meal_item_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [meal_item!]!
}

"aggregate stddev on columns"
type meal_item_stddev_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate stddev_pop on columns"
type meal_item_stddev_pop_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate stddev_samp on columns"
type meal_item_stddev_samp_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate sum on columns"
type meal_item_sum_fields {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    proteins: numeric
    weight: numeric
}

"aggregate var_pop on columns"
type meal_item_var_pop_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate var_samp on columns"
type meal_item_var_samp_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate variance on columns"
type meal_item_variance_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate max on columns"
type meal_max_fields {
    date: date
    id: uuid
    name: String
    u_id: uuid
}

"aggregate min on columns"
type meal_min_fields {
    date: date
    id: uuid
    name: String
    u_id: uuid
}

"response of any mutation on the table \"meal\""
type meal_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [meal!]!
}

"mutation root"
type mutation_root {
    "delete data from the table: \"food\""
    delete_food(
        "filter the rows which have to be deleted"
        where: food_bool_exp!
    ): food_mutation_response
    "delete single row from the table: \"food\""
    delete_food_by_pk(id: uuid!): food
    "delete data from the table: \"food_type\""
    delete_food_type(
        "filter the rows which have to be deleted"
        where: food_type_bool_exp!
    ): food_type_mutation_response
    "delete single row from the table: \"food_type\""
    delete_food_type_by_pk(value: String!): food_type
    "delete data from the table: \"meal\""
    delete_meal(
        "filter the rows which have to be deleted"
        where: meal_bool_exp!
    ): meal_mutation_response
    "delete single row from the table: \"meal\""
    delete_meal_by_pk(id: uuid!): meal
    "delete data from the table: \"meal_item\""
    delete_meal_item(
        "filter the rows which have to be deleted"
        where: meal_item_bool_exp!
    ): meal_item_mutation_response
    "delete single row from the table: \"meal_item\""
    delete_meal_item_by_pk(id: uuid!): meal_item
    "delete data from the table: \"recipe\""
    delete_recipe(
        "filter the rows which have to be deleted"
        where: recipe_bool_exp!
    ): recipe_mutation_response
    "delete single row from the table: \"recipe\""
    delete_recipe_by_pk(id: uuid!): recipe
    "delete data from the table: \"recipe_item\""
    delete_recipe_item(
        "filter the rows which have to be deleted"
        where: recipe_item_bool_exp!
    ): recipe_item_mutation_response
    "delete single row from the table: \"recipe_item\""
    delete_recipe_item_by_pk(id: uuid!): recipe_item
    "delete data from the table: \"users\""
    delete_users(
        "filter the rows which have to be deleted"
        where: users_bool_exp!
    ): users_mutation_response
    "delete single row from the table: \"users\""
    delete_users_by_pk(id: uuid!): users
    "insert data into the table: \"food\""
    insert_food(
        "the rows to be inserted"
        objects: [food_insert_input!]!,
        "on conflict condition"
        on_conflict: food_on_conflict
    ): food_mutation_response
    "insert a single row into the table: \"food\""
    insert_food_one(
        "the row to be inserted"
        object: food_insert_input!,
        "on conflict condition"
        on_conflict: food_on_conflict
    ): food
    "insert data into the table: \"food_type\""
    insert_food_type(
        "the rows to be inserted"
        objects: [food_type_insert_input!]!,
        "on conflict condition"
        on_conflict: food_type_on_conflict
    ): food_type_mutation_response
    "insert a single row into the table: \"food_type\""
    insert_food_type_one(
        "the row to be inserted"
        object: food_type_insert_input!,
        "on conflict condition"
        on_conflict: food_type_on_conflict
    ): food_type
    "insert data into the table: \"meal\""
    insert_meal(
        "the rows to be inserted"
        objects: [meal_insert_input!]!,
        "on conflict condition"
        on_conflict: meal_on_conflict
    ): meal_mutation_response
    "insert data into the table: \"meal_item\""
    insert_meal_item(
        "the rows to be inserted"
        objects: [meal_item_insert_input!]!,
        "on conflict condition"
        on_conflict: meal_item_on_conflict
    ): meal_item_mutation_response
    "insert a single row into the table: \"meal_item\""
    insert_meal_item_one(
        "the row to be inserted"
        object: meal_item_insert_input!,
        "on conflict condition"
        on_conflict: meal_item_on_conflict
    ): meal_item
    "insert a single row into the table: \"meal\""
    insert_meal_one(
        "the row to be inserted"
        object: meal_insert_input!,
        "on conflict condition"
        on_conflict: meal_on_conflict
    ): meal
    "insert data into the table: \"recipe\""
    insert_recipe(
        "the rows to be inserted"
        objects: [recipe_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_on_conflict
    ): recipe_mutation_response
    "insert data into the table: \"recipe_item\""
    insert_recipe_item(
        "the rows to be inserted"
        objects: [recipe_item_insert_input!]!,
        "on conflict condition"
        on_conflict: recipe_item_on_conflict
    ): recipe_item_mutation_response
    "insert a single row into the table: \"recipe_item\""
    insert_recipe_item_one(
        "the row to be inserted"
        object: recipe_item_insert_input!,
        "on conflict condition"
        on_conflict: recipe_item_on_conflict
    ): recipe_item
    "insert a single row into the table: \"recipe\""
    insert_recipe_one(
        "the row to be inserted"
        object: recipe_insert_input!,
        "on conflict condition"
        on_conflict: recipe_on_conflict
    ): recipe
    "insert data into the table: \"users\""
    insert_users(
        "the rows to be inserted"
        objects: [users_insert_input!]!,
        "on conflict condition"
        on_conflict: users_on_conflict
    ): users_mutation_response
    "insert a single row into the table: \"users\""
    insert_users_one(
        "the row to be inserted"
        object: users_insert_input!,
        "on conflict condition"
        on_conflict: users_on_conflict
    ): users
    "update data of the table: \"food\""
    update_food(
        "increments the integer columns with given value of the filtered values"
        _inc: food_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_set_input,
        "filter the rows which have to be updated"
        where: food_bool_exp!
    ): food_mutation_response
    "update single row of the table: \"food\""
    update_food_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: food_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: food_set_input,
        pk_columns: food_pk_columns_input!
    ): food
    "update data of the table: \"food_type\""
    update_food_type(
        "sets the columns of the filtered rows to the given values"
        _set: food_type_set_input,
        "filter the rows which have to be updated"
        where: food_type_bool_exp!
    ): food_type_mutation_response
    "update single row of the table: \"food_type\""
    update_food_type_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: food_type_set_input,
        pk_columns: food_type_pk_columns_input!
    ): food_type
    "update data of the table: \"meal\""
    update_meal(
        "sets the columns of the filtered rows to the given values"
        _set: meal_set_input,
        "filter the rows which have to be updated"
        where: meal_bool_exp!
    ): meal_mutation_response
    "update single row of the table: \"meal\""
    update_meal_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: meal_set_input,
        pk_columns: meal_pk_columns_input!
    ): meal
    "update data of the table: \"meal_item\""
    update_meal_item(
        "increments the integer columns with given value of the filtered values"
        _inc: meal_item_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: meal_item_set_input,
        "filter the rows which have to be updated"
        where: meal_item_bool_exp!
    ): meal_item_mutation_response
    "update single row of the table: \"meal_item\""
    update_meal_item_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: meal_item_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: meal_item_set_input,
        pk_columns: meal_item_pk_columns_input!
    ): meal_item
    "update data of the table: \"recipe\""
    update_recipe(
        "increments the integer columns with given value of the filtered values"
        _inc: recipe_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_set_input,
        "filter the rows which have to be updated"
        where: recipe_bool_exp!
    ): recipe_mutation_response
    "update single row of the table: \"recipe\""
    update_recipe_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: recipe_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_set_input,
        pk_columns: recipe_pk_columns_input!
    ): recipe
    "update data of the table: \"recipe_item\""
    update_recipe_item(
        "increments the integer columns with given value of the filtered values"
        _inc: recipe_item_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_item_set_input,
        "filter the rows which have to be updated"
        where: recipe_item_bool_exp!
    ): recipe_item_mutation_response
    "update single row of the table: \"recipe_item\""
    update_recipe_item_by_pk(
        "increments the integer columns with given value of the filtered values"
        _inc: recipe_item_inc_input,
        "sets the columns of the filtered rows to the given values"
        _set: recipe_item_set_input,
        pk_columns: recipe_item_pk_columns_input!
    ): recipe_item
    "update data of the table: \"users\""
    update_users(
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input,
        "filter the rows which have to be updated"
        where: users_bool_exp!
    ): users_mutation_response
    "update single row of the table: \"users\""
    update_users_by_pk(
        "sets the columns of the filtered rows to the given values"
        _set: users_set_input,
        pk_columns: users_pk_columns_input!
    ): users
}

"query root"
type query_root {
    "fetch data from the table: \"food\""
    food(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): [food!]!
    "fetch aggregated fields from the table: \"food\""
    food_aggregate(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): food_aggregate!
    "fetch data from the table: \"food\" using primary key columns"
    food_by_pk(id: uuid!): food
    "fetch data from the table: \"food_type\""
    food_type(
        "distinct select on columns"
        distinct_on: [food_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_type_order_by!],
        "filter the rows returned"
        where: food_type_bool_exp
    ): [food_type!]!
    "fetch aggregated fields from the table: \"food_type\""
    food_type_aggregate(
        "distinct select on columns"
        distinct_on: [food_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_type_order_by!],
        "filter the rows returned"
        where: food_type_bool_exp
    ): food_type_aggregate!
    "fetch data from the table: \"food_type\" using primary key columns"
    food_type_by_pk(value: String!): food_type
    "fetch data from the table: \"meal\""
    meal(
        "distinct select on columns"
        distinct_on: [meal_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_order_by!],
        "filter the rows returned"
        where: meal_bool_exp
    ): [meal!]!
    "fetch aggregated fields from the table: \"meal\""
    meal_aggregate(
        "distinct select on columns"
        distinct_on: [meal_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_order_by!],
        "filter the rows returned"
        where: meal_bool_exp
    ): meal_aggregate!
    "fetch data from the table: \"meal\" using primary key columns"
    meal_by_pk(id: uuid!): meal
    "fetch data from the table: \"meal_item\""
    meal_item(
        "distinct select on columns"
        distinct_on: [meal_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_item_order_by!],
        "filter the rows returned"
        where: meal_item_bool_exp
    ): [meal_item!]!
    "fetch aggregated fields from the table: \"meal_item\""
    meal_item_aggregate(
        "distinct select on columns"
        distinct_on: [meal_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_item_order_by!],
        "filter the rows returned"
        where: meal_item_bool_exp
    ): meal_item_aggregate!
    "fetch data from the table: \"meal_item\" using primary key columns"
    meal_item_by_pk(id: uuid!): meal_item
    "fetch data from the table: \"recipe\""
    recipe(
        "distinct select on columns"
        distinct_on: [recipe_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_order_by!],
        "filter the rows returned"
        where: recipe_bool_exp
    ): [recipe!]!
    "fetch aggregated fields from the table: \"recipe\""
    recipe_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_order_by!],
        "filter the rows returned"
        where: recipe_bool_exp
    ): recipe_aggregate!
    "fetch data from the table: \"recipe\" using primary key columns"
    recipe_by_pk(id: uuid!): recipe
    "fetch data from the table: \"recipe_item\""
    recipe_item(
        "distinct select on columns"
        distinct_on: [recipe_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_item_order_by!],
        "filter the rows returned"
        where: recipe_item_bool_exp
    ): [recipe_item!]!
    "fetch aggregated fields from the table: \"recipe_item\""
    recipe_item_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_item_order_by!],
        "filter the rows returned"
        where: recipe_item_bool_exp
    ): recipe_item_aggregate!
    "fetch data from the table: \"recipe_item\" using primary key columns"
    recipe_item_by_pk(id: uuid!): recipe_item
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    "fetch data from the table: \"users\" using primary key columns"
    users_by_pk(id: uuid!): users
}

"columns and relationships of \"recipe\""
type recipe {
    description: String
    id: uuid!
    increment: Int!
    name: String!
    "An array relationship"
    recipe_items(
        "distinct select on columns"
        distinct_on: [recipe_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_item_order_by!],
        "filter the rows returned"
        where: recipe_item_bool_exp
    ): [recipe_item!]!
    "An aggregated array relationship"
    recipe_items_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_item_order_by!],
        "filter the rows returned"
        where: recipe_item_bool_exp
    ): recipe_item_aggregate!
    u_id: uuid!
    "An object relationship"
    user: users!
}

"aggregated selection of \"recipe\""
type recipe_aggregate {
    aggregate: recipe_aggregate_fields
    nodes: [recipe!]!
}

"aggregate fields of \"recipe\""
type recipe_aggregate_fields {
    avg: recipe_avg_fields
    count(columns: [recipe_select_column!], distinct: Boolean): Int
    max: recipe_max_fields
    min: recipe_min_fields
    stddev: recipe_stddev_fields
    stddev_pop: recipe_stddev_pop_fields
    stddev_samp: recipe_stddev_samp_fields
    sum: recipe_sum_fields
    var_pop: recipe_var_pop_fields
    var_samp: recipe_var_samp_fields
    variance: recipe_variance_fields
}

"aggregate avg on columns"
type recipe_avg_fields {
    increment: Float
}

"columns and relationships of \"recipe_item\""
type recipe_item {
    carbohydrates: numeric!
    energy_cal: numeric!
    energy_kj: numeric!
    fats: numeric!
    "An object relationship"
    food: food!
    food_id: uuid!
    id: uuid!
    proteins: numeric!
    "An object relationship"
    recipe: recipe!
    recipe_id: uuid!
    u_id: uuid!
    "An object relationship"
    user: users!
    weight: numeric!
}

"aggregated selection of \"recipe_item\""
type recipe_item_aggregate {
    aggregate: recipe_item_aggregate_fields
    nodes: [recipe_item!]!
}

"aggregate fields of \"recipe_item\""
type recipe_item_aggregate_fields {
    avg: recipe_item_avg_fields
    count(columns: [recipe_item_select_column!], distinct: Boolean): Int
    max: recipe_item_max_fields
    min: recipe_item_min_fields
    stddev: recipe_item_stddev_fields
    stddev_pop: recipe_item_stddev_pop_fields
    stddev_samp: recipe_item_stddev_samp_fields
    sum: recipe_item_sum_fields
    var_pop: recipe_item_var_pop_fields
    var_samp: recipe_item_var_samp_fields
    variance: recipe_item_variance_fields
}

"aggregate avg on columns"
type recipe_item_avg_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate max on columns"
type recipe_item_max_fields {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food_id: uuid
    id: uuid
    proteins: numeric
    recipe_id: uuid
    u_id: uuid
    weight: numeric
}

"aggregate min on columns"
type recipe_item_min_fields {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food_id: uuid
    id: uuid
    proteins: numeric
    recipe_id: uuid
    u_id: uuid
    weight: numeric
}

"response of any mutation on the table \"recipe_item\""
type recipe_item_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [recipe_item!]!
}

"aggregate stddev on columns"
type recipe_item_stddev_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate stddev_pop on columns"
type recipe_item_stddev_pop_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate stddev_samp on columns"
type recipe_item_stddev_samp_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate sum on columns"
type recipe_item_sum_fields {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    proteins: numeric
    weight: numeric
}

"aggregate var_pop on columns"
type recipe_item_var_pop_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate var_samp on columns"
type recipe_item_var_samp_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate variance on columns"
type recipe_item_variance_fields {
    carbohydrates: Float
    energy_cal: Float
    energy_kj: Float
    fats: Float
    proteins: Float
    weight: Float
}

"aggregate max on columns"
type recipe_max_fields {
    description: String
    id: uuid
    increment: Int
    name: String
    u_id: uuid
}

"aggregate min on columns"
type recipe_min_fields {
    description: String
    id: uuid
    increment: Int
    name: String
    u_id: uuid
}

"response of any mutation on the table \"recipe\""
type recipe_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [recipe!]!
}

"aggregate stddev on columns"
type recipe_stddev_fields {
    increment: Float
}

"aggregate stddev_pop on columns"
type recipe_stddev_pop_fields {
    increment: Float
}

"aggregate stddev_samp on columns"
type recipe_stddev_samp_fields {
    increment: Float
}

"aggregate sum on columns"
type recipe_sum_fields {
    increment: Int
}

"aggregate var_pop on columns"
type recipe_var_pop_fields {
    increment: Float
}

"aggregate var_samp on columns"
type recipe_var_samp_fields {
    increment: Float
}

"aggregate variance on columns"
type recipe_variance_fields {
    increment: Float
}

"subscription root"
type subscription_root {
    "fetch data from the table: \"food\""
    food(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): [food!]!
    "fetch aggregated fields from the table: \"food\""
    food_aggregate(
        "distinct select on columns"
        distinct_on: [food_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_order_by!],
        "filter the rows returned"
        where: food_bool_exp
    ): food_aggregate!
    "fetch data from the table: \"food\" using primary key columns"
    food_by_pk(id: uuid!): food
    "fetch data from the table: \"food_type\""
    food_type(
        "distinct select on columns"
        distinct_on: [food_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_type_order_by!],
        "filter the rows returned"
        where: food_type_bool_exp
    ): [food_type!]!
    "fetch aggregated fields from the table: \"food_type\""
    food_type_aggregate(
        "distinct select on columns"
        distinct_on: [food_type_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [food_type_order_by!],
        "filter the rows returned"
        where: food_type_bool_exp
    ): food_type_aggregate!
    "fetch data from the table: \"food_type\" using primary key columns"
    food_type_by_pk(value: String!): food_type
    "fetch data from the table: \"meal\""
    meal(
        "distinct select on columns"
        distinct_on: [meal_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_order_by!],
        "filter the rows returned"
        where: meal_bool_exp
    ): [meal!]!
    "fetch aggregated fields from the table: \"meal\""
    meal_aggregate(
        "distinct select on columns"
        distinct_on: [meal_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_order_by!],
        "filter the rows returned"
        where: meal_bool_exp
    ): meal_aggregate!
    "fetch data from the table: \"meal\" using primary key columns"
    meal_by_pk(id: uuid!): meal
    "fetch data from the table: \"meal_item\""
    meal_item(
        "distinct select on columns"
        distinct_on: [meal_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_item_order_by!],
        "filter the rows returned"
        where: meal_item_bool_exp
    ): [meal_item!]!
    "fetch aggregated fields from the table: \"meal_item\""
    meal_item_aggregate(
        "distinct select on columns"
        distinct_on: [meal_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [meal_item_order_by!],
        "filter the rows returned"
        where: meal_item_bool_exp
    ): meal_item_aggregate!
    "fetch data from the table: \"meal_item\" using primary key columns"
    meal_item_by_pk(id: uuid!): meal_item
    "fetch data from the table: \"recipe\""
    recipe(
        "distinct select on columns"
        distinct_on: [recipe_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_order_by!],
        "filter the rows returned"
        where: recipe_bool_exp
    ): [recipe!]!
    "fetch aggregated fields from the table: \"recipe\""
    recipe_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_order_by!],
        "filter the rows returned"
        where: recipe_bool_exp
    ): recipe_aggregate!
    "fetch data from the table: \"recipe\" using primary key columns"
    recipe_by_pk(id: uuid!): recipe
    "fetch data from the table: \"recipe_item\""
    recipe_item(
        "distinct select on columns"
        distinct_on: [recipe_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_item_order_by!],
        "filter the rows returned"
        where: recipe_item_bool_exp
    ): [recipe_item!]!
    "fetch aggregated fields from the table: \"recipe_item\""
    recipe_item_aggregate(
        "distinct select on columns"
        distinct_on: [recipe_item_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [recipe_item_order_by!],
        "filter the rows returned"
        where: recipe_item_bool_exp
    ): recipe_item_aggregate!
    "fetch data from the table: \"recipe_item\" using primary key columns"
    recipe_item_by_pk(id: uuid!): recipe_item
    "fetch data from the table: \"users\""
    users(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): [users!]!
    "fetch aggregated fields from the table: \"users\""
    users_aggregate(
        "distinct select on columns"
        distinct_on: [users_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [users_order_by!],
        "filter the rows returned"
        where: users_bool_exp
    ): users_aggregate!
    "fetch data from the table: \"users\" using primary key columns"
    users_by_pk(id: uuid!): users
}

"""

List of users


columns and relationships of "users"
"""
type users {
    fb_id: String
    fb_picture_url: String
    first_name: name
    full_name: String
    id: uuid!
    last_name: name
    password: String
    user_name: name
}

"aggregated selection of \"users\""
type users_aggregate {
    aggregate: users_aggregate_fields
    nodes: [users!]!
}

"aggregate fields of \"users\""
type users_aggregate_fields {
    count(columns: [users_select_column!], distinct: Boolean): Int
    max: users_max_fields
    min: users_min_fields
}

"aggregate max on columns"
type users_max_fields {
    fb_id: String
    fb_picture_url: String
    full_name: String
    id: uuid
    password: String
}

"aggregate min on columns"
type users_min_fields {
    fb_id: String
    fb_picture_url: String
    full_name: String
    id: uuid
    password: String
}

"response of any mutation on the table \"users\""
type users_mutation_response {
    "number of affected rows by the mutation"
    affected_rows: Int!
    "data of the affected rows by the mutation"
    returning: [users!]!
}

"unique or primary key constraints on table \"food\""
enum food_constraint {
    "unique or primary key constraint"
    food_pkey
}

"select columns of table \"food\""
enum food_select_column {
    "column name"
    A
    "column name"
    B1
    "column name"
    B12
    "column name"
    B2
    "column name"
    B3
    "column name"
    B5
    "column name"
    B6
    "column name"
    B7
    "column name"
    B9
    "column name"
    C
    "column name"
    D
    "column name"
    E
    "column name"
    K
    "column name"
    calcium
    "column name"
    carbohydrates
    "column name"
    carbohydrates_fiber
    "column name"
    carbohydrates_starch
    "column name"
    carbohydrates_sugars
    "column name"
    copper
    "column name"
    energy_cal
    "column name"
    energy_kj
    "column name"
    fats
    "column name"
    id
    "column name"
    iron
    "column name"
    magnesium
    "column name"
    manganese
    "column name"
    name
    "column name"
    phosphorus
    "column name"
    potassium
    "column name"
    proteins
    "column name"
    selenium
    "column name"
    sodium
    "column name"
    type
    "column name"
    weight
    "column name"
    zinc
}

"unique or primary key constraints on table \"food_type\""
enum food_type_constraint {
    "unique or primary key constraint"
    food_type_pkey
}

"select columns of table \"food_type\""
enum food_type_select_column {
    "column name"
    decription
    "column name"
    value
}

"update columns of table \"food_type\""
enum food_type_update_column {
    "column name"
    decription
    "column name"
    value
}

"update columns of table \"food\""
enum food_update_column {
    "column name"
    A
    "column name"
    B1
    "column name"
    B12
    "column name"
    B2
    "column name"
    B3
    "column name"
    B5
    "column name"
    B6
    "column name"
    B7
    "column name"
    B9
    "column name"
    C
    "column name"
    D
    "column name"
    E
    "column name"
    K
    "column name"
    calcium
    "column name"
    carbohydrates
    "column name"
    carbohydrates_fiber
    "column name"
    carbohydrates_starch
    "column name"
    carbohydrates_sugars
    "column name"
    copper
    "column name"
    energy_cal
    "column name"
    energy_kj
    "column name"
    fats
    "column name"
    id
    "column name"
    iron
    "column name"
    magnesium
    "column name"
    manganese
    "column name"
    name
    "column name"
    phosphorus
    "column name"
    potassium
    "column name"
    proteins
    "column name"
    selenium
    "column name"
    sodium
    "column name"
    type
    "column name"
    weight
    "column name"
    zinc
}

"unique or primary key constraints on table \"meal\""
enum meal_constraint {
    "unique or primary key constraint"
    meal_pkey1
}

"unique or primary key constraints on table \"meal_item\""
enum meal_item_constraint {
    "unique or primary key constraint"
    meal_item_pkey
}

"select columns of table \"meal_item\""
enum meal_item_select_column {
    "column name"
    carbohydrates
    "column name"
    energy_cal
    "column name"
    energy_kj
    "column name"
    fats
    "column name"
    food
    "column name"
    id
    "column name"
    meal_id
    "column name"
    proteins
    "column name"
    recipe_id
    "column name"
    u_id
    "column name"
    weight
}

"update columns of table \"meal_item\""
enum meal_item_update_column {
    "column name"
    carbohydrates
    "column name"
    energy_cal
    "column name"
    energy_kj
    "column name"
    fats
    "column name"
    food
    "column name"
    id
    "column name"
    meal_id
    "column name"
    proteins
    "column name"
    recipe_id
    "column name"
    u_id
    "column name"
    weight
}

"select columns of table \"meal\""
enum meal_select_column {
    "column name"
    date
    "column name"
    id
    "column name"
    name
    "column name"
    time
    "column name"
    u_id
}

"update columns of table \"meal\""
enum meal_update_column {
    "column name"
    date
    "column name"
    id
    "column name"
    name
    "column name"
    time
    "column name"
    u_id
}

"column ordering options"
enum order_by {
    "in the ascending order, nulls last"
    asc
    "in the ascending order, nulls first"
    asc_nulls_first
    "in the ascending order, nulls last"
    asc_nulls_last
    "in the descending order, nulls first"
    desc
    "in the descending order, nulls first"
    desc_nulls_first
    "in the descending order, nulls last"
    desc_nulls_last
}

"unique or primary key constraints on table \"recipe\""
enum recipe_constraint {
    "unique or primary key constraint"
    recipe_increment_key
    "unique or primary key constraint"
    recipe_pkey
}

"unique or primary key constraints on table \"recipe_item\""
enum recipe_item_constraint {
    "unique or primary key constraint"
    recipe_item_pkey
}

"select columns of table \"recipe_item\""
enum recipe_item_select_column {
    "column name"
    carbohydrates
    "column name"
    energy_cal
    "column name"
    energy_kj
    "column name"
    fats
    "column name"
    food_id
    "column name"
    id
    "column name"
    proteins
    "column name"
    recipe_id
    "column name"
    u_id
    "column name"
    weight
}

"update columns of table \"recipe_item\""
enum recipe_item_update_column {
    "column name"
    carbohydrates
    "column name"
    energy_cal
    "column name"
    energy_kj
    "column name"
    fats
    "column name"
    food_id
    "column name"
    id
    "column name"
    proteins
    "column name"
    recipe_id
    "column name"
    u_id
    "column name"
    weight
}

"select columns of table \"recipe\""
enum recipe_select_column {
    "column name"
    description
    "column name"
    id
    "column name"
    increment
    "column name"
    name
    "column name"
    u_id
}

"update columns of table \"recipe\""
enum recipe_update_column {
    "column name"
    description
    "column name"
    id
    "column name"
    increment
    "column name"
    name
    "column name"
    u_id
}

"unique or primary key constraints on table \"users\""
enum users_constraint {
    "unique or primary key constraint"
    users_fb_id_key
    "unique or primary key constraint"
    users_fb_picture_url_key
    "unique or primary key constraint"
    users_password_key
    "unique or primary key constraint"
    users_pkey
    "unique or primary key constraint"
    users_user_name_key
}

"select columns of table \"users\""
enum users_select_column {
    "column name"
    fb_id
    "column name"
    fb_picture_url
    "column name"
    first_name
    "column name"
    full_name
    "column name"
    id
    "column name"
    last_name
    "column name"
    password
    "column name"
    user_name
}

"update columns of table \"users\""
enum users_update_column {
    "column name"
    fb_id
    "column name"
    fb_picture_url
    "column name"
    first_name
    "column name"
    full_name
    "column name"
    id
    "column name"
    last_name
    "column name"
    password
    "column name"
    user_name
}

"expression to compare columns of type Int. All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"expression to compare columns of type String. All fields are combined with logical 'AND'."
input String_comparison_exp {
    _eq: String
    _gt: String
    _gte: String
    _ilike: String
    _in: [String!]
    _is_null: Boolean
    _like: String
    _lt: String
    _lte: String
    _neq: String
    _nilike: String
    _nin: [String!]
    _nlike: String
    _nsimilar: String
    _similar: String
}

"expression to compare columns of type bpchar. All fields are combined with logical 'AND'."
input bpchar_comparison_exp {
    _eq: bpchar
    _gt: bpchar
    _gte: bpchar
    _in: [bpchar!]
    _is_null: Boolean
    _lt: bpchar
    _lte: bpchar
    _neq: bpchar
    _nin: [bpchar!]
}

"expression to compare columns of type date. All fields are combined with logical 'AND'."
input date_comparison_exp {
    _eq: date
    _gt: date
    _gte: date
    _in: [date!]
    _is_null: Boolean
    _lt: date
    _lte: date
    _neq: date
    _nin: [date!]
}

"order by aggregate values of table \"food\""
input food_aggregate_order_by {
    avg: food_avg_order_by
    count: order_by
    max: food_max_order_by
    min: food_min_order_by
    stddev: food_stddev_order_by
    stddev_pop: food_stddev_pop_order_by
    stddev_samp: food_stddev_samp_order_by
    sum: food_sum_order_by
    var_pop: food_var_pop_order_by
    var_samp: food_var_samp_order_by
    variance: food_variance_order_by
}

"input type for inserting array relation for remote table \"food\""
input food_arr_rel_insert_input {
    data: [food_insert_input!]!
    on_conflict: food_on_conflict
}

"order by avg() on columns of table \"food\""
input food_avg_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    weight: order_by
    zinc: order_by
}

"Boolean expression to filter rows from the table \"food\". All fields are combined with a logical 'AND'."
input food_bool_exp {
    A: numeric_comparison_exp
    B1: numeric_comparison_exp
    B12: numeric_comparison_exp
    B2: numeric_comparison_exp
    B3: numeric_comparison_exp
    B5: numeric_comparison_exp
    B6: numeric_comparison_exp
    B7: numeric_comparison_exp
    B9: numeric_comparison_exp
    C: numeric_comparison_exp
    D: numeric_comparison_exp
    E: numeric_comparison_exp
    K: numeric_comparison_exp
    _and: [food_bool_exp]
    _not: food_bool_exp
    _or: [food_bool_exp]
    calcium: numeric_comparison_exp
    carbohydrates: numeric_comparison_exp
    carbohydrates_fiber: numeric_comparison_exp
    carbohydrates_starch: numeric_comparison_exp
    carbohydrates_sugars: numeric_comparison_exp
    copper: numeric_comparison_exp
    energy_cal: numeric_comparison_exp
    energy_kj: numeric_comparison_exp
    fats: numeric_comparison_exp
    food_type: food_type_bool_exp
    id: uuid_comparison_exp
    iron: numeric_comparison_exp
    magnesium: numeric_comparison_exp
    manganese: numeric_comparison_exp
    meal_items: meal_item_bool_exp
    name: bpchar_comparison_exp
    phosphorus: numeric_comparison_exp
    potassium: numeric_comparison_exp
    proteins: numeric_comparison_exp
    selenium: numeric_comparison_exp
    sodium: numeric_comparison_exp
    type: String_comparison_exp
    weight: Int_comparison_exp
    zinc: numeric_comparison_exp
}

"input type for incrementing integer column in table \"food\""
input food_inc_input {
    A: numeric
    B1: numeric
    B12: numeric
    B2: numeric
    B3: numeric
    B5: numeric
    B6: numeric
    B7: numeric
    B9: numeric
    C: numeric
    D: numeric
    E: numeric
    K: numeric
    calcium: numeric
    carbohydrates: numeric
    carbohydrates_fiber: numeric
    carbohydrates_starch: numeric
    carbohydrates_sugars: numeric
    copper: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    iron: numeric
    magnesium: numeric
    manganese: numeric
    phosphorus: numeric
    potassium: numeric
    proteins: numeric
    selenium: numeric
    sodium: numeric
    weight: Int
    zinc: numeric
}

"input type for inserting data into table \"food\""
input food_insert_input {
    A: numeric
    B1: numeric
    B12: numeric
    B2: numeric
    B3: numeric
    B5: numeric
    B6: numeric
    B7: numeric
    B9: numeric
    C: numeric
    D: numeric
    E: numeric
    K: numeric
    calcium: numeric
    carbohydrates: numeric
    carbohydrates_fiber: numeric
    carbohydrates_starch: numeric
    carbohydrates_sugars: numeric
    copper: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food_type: food_type_obj_rel_insert_input
    id: uuid
    iron: numeric
    magnesium: numeric
    manganese: numeric
    meal_items: meal_item_arr_rel_insert_input
    name: bpchar
    phosphorus: numeric
    potassium: numeric
    proteins: numeric
    selenium: numeric
    sodium: numeric
    type: String
    weight: Int
    zinc: numeric
}

"order by max() on columns of table \"food\""
input food_max_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    id: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    type: order_by
    weight: order_by
    zinc: order_by
}

"order by min() on columns of table \"food\""
input food_min_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    id: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    type: order_by
    weight: order_by
    zinc: order_by
}

"input type for inserting object relation for remote table \"food\""
input food_obj_rel_insert_input {
    data: food_insert_input!
    on_conflict: food_on_conflict
}

"on conflict condition type for table \"food\""
input food_on_conflict {
    constraint: food_constraint!
    update_columns: [food_update_column!]!
    where: food_bool_exp
}

"ordering options when selecting data from \"food\""
input food_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    food_type: food_type_order_by
    id: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    meal_items_aggregate: meal_item_aggregate_order_by
    name: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    type: order_by
    weight: order_by
    zinc: order_by
}

"primary key columns input for table: \"food\""
input food_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"food\""
input food_set_input {
    A: numeric
    B1: numeric
    B12: numeric
    B2: numeric
    B3: numeric
    B5: numeric
    B6: numeric
    B7: numeric
    B9: numeric
    C: numeric
    D: numeric
    E: numeric
    K: numeric
    calcium: numeric
    carbohydrates: numeric
    carbohydrates_fiber: numeric
    carbohydrates_starch: numeric
    carbohydrates_sugars: numeric
    copper: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    id: uuid
    iron: numeric
    magnesium: numeric
    manganese: numeric
    name: bpchar
    phosphorus: numeric
    potassium: numeric
    proteins: numeric
    selenium: numeric
    sodium: numeric
    type: String
    weight: Int
    zinc: numeric
}

"order by stddev() on columns of table \"food\""
input food_stddev_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    weight: order_by
    zinc: order_by
}

"order by stddev_pop() on columns of table \"food\""
input food_stddev_pop_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    weight: order_by
    zinc: order_by
}

"order by stddev_samp() on columns of table \"food\""
input food_stddev_samp_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    weight: order_by
    zinc: order_by
}

"order by sum() on columns of table \"food\""
input food_sum_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    weight: order_by
    zinc: order_by
}

"order by aggregate values of table \"food_type\""
input food_type_aggregate_order_by {
    count: order_by
    max: food_type_max_order_by
    min: food_type_min_order_by
}

"input type for inserting array relation for remote table \"food_type\""
input food_type_arr_rel_insert_input {
    data: [food_type_insert_input!]!
    on_conflict: food_type_on_conflict
}

"Boolean expression to filter rows from the table \"food_type\". All fields are combined with a logical 'AND'."
input food_type_bool_exp {
    _and: [food_type_bool_exp]
    _not: food_type_bool_exp
    _or: [food_type_bool_exp]
    decription: String_comparison_exp
    food: food_bool_exp
    value: String_comparison_exp
}

"input type for inserting data into table \"food_type\""
input food_type_insert_input {
    decription: String
    food: food_arr_rel_insert_input
    value: String
}

"order by max() on columns of table \"food_type\""
input food_type_max_order_by {
    decription: order_by
    value: order_by
}

"order by min() on columns of table \"food_type\""
input food_type_min_order_by {
    decription: order_by
    value: order_by
}

"input type for inserting object relation for remote table \"food_type\""
input food_type_obj_rel_insert_input {
    data: food_type_insert_input!
    on_conflict: food_type_on_conflict
}

"on conflict condition type for table \"food_type\""
input food_type_on_conflict {
    constraint: food_type_constraint!
    update_columns: [food_type_update_column!]!
    where: food_type_bool_exp
}

"ordering options when selecting data from \"food_type\""
input food_type_order_by {
    decription: order_by
    food_aggregate: food_aggregate_order_by
    value: order_by
}

"primary key columns input for table: \"food_type\""
input food_type_pk_columns_input {
    value: String!
}

"input type for updating data in table \"food_type\""
input food_type_set_input {
    decription: String
    value: String
}

"order by var_pop() on columns of table \"food\""
input food_var_pop_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    weight: order_by
    zinc: order_by
}

"order by var_samp() on columns of table \"food\""
input food_var_samp_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    weight: order_by
    zinc: order_by
}

"order by variance() on columns of table \"food\""
input food_variance_order_by {
    A: order_by
    B1: order_by
    B12: order_by
    B2: order_by
    B3: order_by
    B5: order_by
    B6: order_by
    B7: order_by
    B9: order_by
    C: order_by
    D: order_by
    E: order_by
    K: order_by
    calcium: order_by
    carbohydrates: order_by
    carbohydrates_fiber: order_by
    carbohydrates_starch: order_by
    carbohydrates_sugars: order_by
    copper: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    iron: order_by
    magnesium: order_by
    manganese: order_by
    phosphorus: order_by
    potassium: order_by
    proteins: order_by
    selenium: order_by
    sodium: order_by
    weight: order_by
    zinc: order_by
}

"order by aggregate values of table \"meal\""
input meal_aggregate_order_by {
    count: order_by
    max: meal_max_order_by
    min: meal_min_order_by
}

"input type for inserting array relation for remote table \"meal\""
input meal_arr_rel_insert_input {
    data: [meal_insert_input!]!
    on_conflict: meal_on_conflict
}

"Boolean expression to filter rows from the table \"meal\". All fields are combined with a logical 'AND'."
input meal_bool_exp {
    _and: [meal_bool_exp]
    _not: meal_bool_exp
    _or: [meal_bool_exp]
    date: date_comparison_exp
    id: uuid_comparison_exp
    meal_items: meal_item_bool_exp
    name: String_comparison_exp
    time: time_comparison_exp
    u_id: uuid_comparison_exp
    user: users_bool_exp
}

"input type for inserting data into table \"meal\""
input meal_insert_input {
    date: date
    id: uuid
    meal_items: meal_item_arr_rel_insert_input
    name: String
    time: time
    u_id: uuid
    user: users_obj_rel_insert_input
}

"order by aggregate values of table \"meal_item\""
input meal_item_aggregate_order_by {
    avg: meal_item_avg_order_by
    count: order_by
    max: meal_item_max_order_by
    min: meal_item_min_order_by
    stddev: meal_item_stddev_order_by
    stddev_pop: meal_item_stddev_pop_order_by
    stddev_samp: meal_item_stddev_samp_order_by
    sum: meal_item_sum_order_by
    var_pop: meal_item_var_pop_order_by
    var_samp: meal_item_var_samp_order_by
    variance: meal_item_variance_order_by
}

"input type for inserting array relation for remote table \"meal_item\""
input meal_item_arr_rel_insert_input {
    data: [meal_item_insert_input!]!
    on_conflict: meal_item_on_conflict
}

"order by avg() on columns of table \"meal_item\""
input meal_item_avg_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"Boolean expression to filter rows from the table \"meal_item\". All fields are combined with a logical 'AND'."
input meal_item_bool_exp {
    _and: [meal_item_bool_exp]
    _not: meal_item_bool_exp
    _or: [meal_item_bool_exp]
    carbohydrates: numeric_comparison_exp
    energy_cal: numeric_comparison_exp
    energy_kj: numeric_comparison_exp
    fats: numeric_comparison_exp
    food: uuid_comparison_exp
    foodDesc: food_bool_exp
    id: uuid_comparison_exp
    meal: meal_bool_exp
    meal_id: uuid_comparison_exp
    proteins: numeric_comparison_exp
    recipe: recipe_bool_exp
    recipe_id: uuid_comparison_exp
    u_id: uuid_comparison_exp
    user: users_bool_exp
    weight: numeric_comparison_exp
}

"input type for incrementing integer column in table \"meal_item\""
input meal_item_inc_input {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    proteins: numeric
    weight: numeric
}

"input type for inserting data into table \"meal_item\""
input meal_item_insert_input {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food: uuid
    foodDesc: food_obj_rel_insert_input
    id: uuid
    meal: meal_obj_rel_insert_input
    meal_id: uuid
    proteins: numeric
    recipe: recipe_obj_rel_insert_input
    recipe_id: uuid
    u_id: uuid
    user: users_obj_rel_insert_input
    weight: numeric
}

"order by max() on columns of table \"meal_item\""
input meal_item_max_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    food: order_by
    id: order_by
    meal_id: order_by
    proteins: order_by
    recipe_id: order_by
    u_id: order_by
    weight: order_by
}

"order by min() on columns of table \"meal_item\""
input meal_item_min_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    food: order_by
    id: order_by
    meal_id: order_by
    proteins: order_by
    recipe_id: order_by
    u_id: order_by
    weight: order_by
}

"input type for inserting object relation for remote table \"meal_item\""
input meal_item_obj_rel_insert_input {
    data: meal_item_insert_input!
    on_conflict: meal_item_on_conflict
}

"on conflict condition type for table \"meal_item\""
input meal_item_on_conflict {
    constraint: meal_item_constraint!
    update_columns: [meal_item_update_column!]!
    where: meal_item_bool_exp
}

"ordering options when selecting data from \"meal_item\""
input meal_item_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    food: order_by
    foodDesc: food_order_by
    id: order_by
    meal: meal_order_by
    meal_id: order_by
    proteins: order_by
    recipe: recipe_order_by
    recipe_id: order_by
    u_id: order_by
    user: users_order_by
    weight: order_by
}

"primary key columns input for table: \"meal_item\""
input meal_item_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"meal_item\""
input meal_item_set_input {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food: uuid
    id: uuid
    meal_id: uuid
    proteins: numeric
    recipe_id: uuid
    u_id: uuid
    weight: numeric
}

"order by stddev() on columns of table \"meal_item\""
input meal_item_stddev_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by stddev_pop() on columns of table \"meal_item\""
input meal_item_stddev_pop_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by stddev_samp() on columns of table \"meal_item\""
input meal_item_stddev_samp_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by sum() on columns of table \"meal_item\""
input meal_item_sum_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by var_pop() on columns of table \"meal_item\""
input meal_item_var_pop_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by var_samp() on columns of table \"meal_item\""
input meal_item_var_samp_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by variance() on columns of table \"meal_item\""
input meal_item_variance_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by max() on columns of table \"meal\""
input meal_max_order_by {
    date: order_by
    id: order_by
    name: order_by
    u_id: order_by
}

"order by min() on columns of table \"meal\""
input meal_min_order_by {
    date: order_by
    id: order_by
    name: order_by
    u_id: order_by
}

"input type for inserting object relation for remote table \"meal\""
input meal_obj_rel_insert_input {
    data: meal_insert_input!
    on_conflict: meal_on_conflict
}

"on conflict condition type for table \"meal\""
input meal_on_conflict {
    constraint: meal_constraint!
    update_columns: [meal_update_column!]!
    where: meal_bool_exp
}

"ordering options when selecting data from \"meal\""
input meal_order_by {
    date: order_by
    id: order_by
    meal_items_aggregate: meal_item_aggregate_order_by
    name: order_by
    time: order_by
    u_id: order_by
    user: users_order_by
}

"primary key columns input for table: \"meal\""
input meal_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"meal\""
input meal_set_input {
    date: date
    id: uuid
    name: String
    time: time
    u_id: uuid
}

"expression to compare columns of type name. All fields are combined with logical 'AND'."
input name_comparison_exp {
    _eq: name
    _gt: name
    _gte: name
    _in: [name!]
    _is_null: Boolean
    _lt: name
    _lte: name
    _neq: name
    _nin: [name!]
}

"expression to compare columns of type numeric. All fields are combined with logical 'AND'."
input numeric_comparison_exp {
    _eq: numeric
    _gt: numeric
    _gte: numeric
    _in: [numeric!]
    _is_null: Boolean
    _lt: numeric
    _lte: numeric
    _neq: numeric
    _nin: [numeric!]
}

"order by aggregate values of table \"recipe\""
input recipe_aggregate_order_by {
    avg: recipe_avg_order_by
    count: order_by
    max: recipe_max_order_by
    min: recipe_min_order_by
    stddev: recipe_stddev_order_by
    stddev_pop: recipe_stddev_pop_order_by
    stddev_samp: recipe_stddev_samp_order_by
    sum: recipe_sum_order_by
    var_pop: recipe_var_pop_order_by
    var_samp: recipe_var_samp_order_by
    variance: recipe_variance_order_by
}

"input type for inserting array relation for remote table \"recipe\""
input recipe_arr_rel_insert_input {
    data: [recipe_insert_input!]!
    on_conflict: recipe_on_conflict
}

"order by avg() on columns of table \"recipe\""
input recipe_avg_order_by {
    increment: order_by
}

"Boolean expression to filter rows from the table \"recipe\". All fields are combined with a logical 'AND'."
input recipe_bool_exp {
    _and: [recipe_bool_exp]
    _not: recipe_bool_exp
    _or: [recipe_bool_exp]
    description: String_comparison_exp
    id: uuid_comparison_exp
    increment: Int_comparison_exp
    name: String_comparison_exp
    recipe_items: recipe_item_bool_exp
    u_id: uuid_comparison_exp
    user: users_bool_exp
}

"input type for incrementing integer column in table \"recipe\""
input recipe_inc_input {
    increment: Int
}

"input type for inserting data into table \"recipe\""
input recipe_insert_input {
    description: String
    id: uuid
    increment: Int
    name: String
    recipe_items: recipe_item_arr_rel_insert_input
    u_id: uuid
    user: users_obj_rel_insert_input
}

"order by aggregate values of table \"recipe_item\""
input recipe_item_aggregate_order_by {
    avg: recipe_item_avg_order_by
    count: order_by
    max: recipe_item_max_order_by
    min: recipe_item_min_order_by
    stddev: recipe_item_stddev_order_by
    stddev_pop: recipe_item_stddev_pop_order_by
    stddev_samp: recipe_item_stddev_samp_order_by
    sum: recipe_item_sum_order_by
    var_pop: recipe_item_var_pop_order_by
    var_samp: recipe_item_var_samp_order_by
    variance: recipe_item_variance_order_by
}

"input type for inserting array relation for remote table \"recipe_item\""
input recipe_item_arr_rel_insert_input {
    data: [recipe_item_insert_input!]!
    on_conflict: recipe_item_on_conflict
}

"order by avg() on columns of table \"recipe_item\""
input recipe_item_avg_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"Boolean expression to filter rows from the table \"recipe_item\". All fields are combined with a logical 'AND'."
input recipe_item_bool_exp {
    _and: [recipe_item_bool_exp]
    _not: recipe_item_bool_exp
    _or: [recipe_item_bool_exp]
    carbohydrates: numeric_comparison_exp
    energy_cal: numeric_comparison_exp
    energy_kj: numeric_comparison_exp
    fats: numeric_comparison_exp
    food: food_bool_exp
    food_id: uuid_comparison_exp
    id: uuid_comparison_exp
    proteins: numeric_comparison_exp
    recipe: recipe_bool_exp
    recipe_id: uuid_comparison_exp
    u_id: uuid_comparison_exp
    user: users_bool_exp
    weight: numeric_comparison_exp
}

"input type for incrementing integer column in table \"recipe_item\""
input recipe_item_inc_input {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    proteins: numeric
    weight: numeric
}

"input type for inserting data into table \"recipe_item\""
input recipe_item_insert_input {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food: food_obj_rel_insert_input
    food_id: uuid
    id: uuid
    proteins: numeric
    recipe: recipe_obj_rel_insert_input
    recipe_id: uuid
    u_id: uuid
    user: users_obj_rel_insert_input
    weight: numeric
}

"order by max() on columns of table \"recipe_item\""
input recipe_item_max_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    food_id: order_by
    id: order_by
    proteins: order_by
    recipe_id: order_by
    u_id: order_by
    weight: order_by
}

"order by min() on columns of table \"recipe_item\""
input recipe_item_min_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    food_id: order_by
    id: order_by
    proteins: order_by
    recipe_id: order_by
    u_id: order_by
    weight: order_by
}

"input type for inserting object relation for remote table \"recipe_item\""
input recipe_item_obj_rel_insert_input {
    data: recipe_item_insert_input!
    on_conflict: recipe_item_on_conflict
}

"on conflict condition type for table \"recipe_item\""
input recipe_item_on_conflict {
    constraint: recipe_item_constraint!
    update_columns: [recipe_item_update_column!]!
    where: recipe_item_bool_exp
}

"ordering options when selecting data from \"recipe_item\""
input recipe_item_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    food: food_order_by
    food_id: order_by
    id: order_by
    proteins: order_by
    recipe: recipe_order_by
    recipe_id: order_by
    u_id: order_by
    user: users_order_by
    weight: order_by
}

"primary key columns input for table: \"recipe_item\""
input recipe_item_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"recipe_item\""
input recipe_item_set_input {
    carbohydrates: numeric
    energy_cal: numeric
    energy_kj: numeric
    fats: numeric
    food_id: uuid
    id: uuid
    proteins: numeric
    recipe_id: uuid
    u_id: uuid
    weight: numeric
}

"order by stddev() on columns of table \"recipe_item\""
input recipe_item_stddev_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by stddev_pop() on columns of table \"recipe_item\""
input recipe_item_stddev_pop_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by stddev_samp() on columns of table \"recipe_item\""
input recipe_item_stddev_samp_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by sum() on columns of table \"recipe_item\""
input recipe_item_sum_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by var_pop() on columns of table \"recipe_item\""
input recipe_item_var_pop_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by var_samp() on columns of table \"recipe_item\""
input recipe_item_var_samp_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by variance() on columns of table \"recipe_item\""
input recipe_item_variance_order_by {
    carbohydrates: order_by
    energy_cal: order_by
    energy_kj: order_by
    fats: order_by
    proteins: order_by
    weight: order_by
}

"order by max() on columns of table \"recipe\""
input recipe_max_order_by {
    description: order_by
    id: order_by
    increment: order_by
    name: order_by
    u_id: order_by
}

"order by min() on columns of table \"recipe\""
input recipe_min_order_by {
    description: order_by
    id: order_by
    increment: order_by
    name: order_by
    u_id: order_by
}

"input type for inserting object relation for remote table \"recipe\""
input recipe_obj_rel_insert_input {
    data: recipe_insert_input!
    on_conflict: recipe_on_conflict
}

"on conflict condition type for table \"recipe\""
input recipe_on_conflict {
    constraint: recipe_constraint!
    update_columns: [recipe_update_column!]!
    where: recipe_bool_exp
}

"ordering options when selecting data from \"recipe\""
input recipe_order_by {
    description: order_by
    id: order_by
    increment: order_by
    name: order_by
    recipe_items_aggregate: recipe_item_aggregate_order_by
    u_id: order_by
    user: users_order_by
}

"primary key columns input for table: \"recipe\""
input recipe_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"recipe\""
input recipe_set_input {
    description: String
    id: uuid
    increment: Int
    name: String
    u_id: uuid
}

"order by stddev() on columns of table \"recipe\""
input recipe_stddev_order_by {
    increment: order_by
}

"order by stddev_pop() on columns of table \"recipe\""
input recipe_stddev_pop_order_by {
    increment: order_by
}

"order by stddev_samp() on columns of table \"recipe\""
input recipe_stddev_samp_order_by {
    increment: order_by
}

"order by sum() on columns of table \"recipe\""
input recipe_sum_order_by {
    increment: order_by
}

"order by var_pop() on columns of table \"recipe\""
input recipe_var_pop_order_by {
    increment: order_by
}

"order by var_samp() on columns of table \"recipe\""
input recipe_var_samp_order_by {
    increment: order_by
}

"order by variance() on columns of table \"recipe\""
input recipe_variance_order_by {
    increment: order_by
}

"expression to compare columns of type time. All fields are combined with logical 'AND'."
input time_comparison_exp {
    _eq: time
    _gt: time
    _gte: time
    _in: [time!]
    _is_null: Boolean
    _lt: time
    _lte: time
    _neq: time
    _nin: [time!]
}

"order by aggregate values of table \"users\""
input users_aggregate_order_by {
    count: order_by
    max: users_max_order_by
    min: users_min_order_by
}

"input type for inserting array relation for remote table \"users\""
input users_arr_rel_insert_input {
    data: [users_insert_input!]!
    on_conflict: users_on_conflict
}

"Boolean expression to filter rows from the table \"users\". All fields are combined with a logical 'AND'."
input users_bool_exp {
    _and: [users_bool_exp]
    _not: users_bool_exp
    _or: [users_bool_exp]
    fb_id: String_comparison_exp
    fb_picture_url: String_comparison_exp
    first_name: name_comparison_exp
    full_name: String_comparison_exp
    id: uuid_comparison_exp
    last_name: name_comparison_exp
    password: String_comparison_exp
    user_name: name_comparison_exp
}

"input type for inserting data into table \"users\""
input users_insert_input {
    fb_id: String
    fb_picture_url: String
    first_name: name
    full_name: String
    id: uuid
    last_name: name
    password: String
    user_name: name
}

"order by max() on columns of table \"users\""
input users_max_order_by {
    fb_id: order_by
    fb_picture_url: order_by
    full_name: order_by
    id: order_by
    password: order_by
}

"order by min() on columns of table \"users\""
input users_min_order_by {
    fb_id: order_by
    fb_picture_url: order_by
    full_name: order_by
    id: order_by
    password: order_by
}

"input type for inserting object relation for remote table \"users\""
input users_obj_rel_insert_input {
    data: users_insert_input!
    on_conflict: users_on_conflict
}

"on conflict condition type for table \"users\""
input users_on_conflict {
    constraint: users_constraint!
    update_columns: [users_update_column!]!
    where: users_bool_exp
}

"ordering options when selecting data from \"users\""
input users_order_by {
    fb_id: order_by
    fb_picture_url: order_by
    first_name: order_by
    full_name: order_by
    id: order_by
    last_name: order_by
    password: order_by
    user_name: order_by
}

"primary key columns input for table: \"users\""
input users_pk_columns_input {
    id: uuid!
}

"input type for updating data in table \"users\""
input users_set_input {
    fb_id: String
    fb_picture_url: String
    first_name: name
    full_name: String
    id: uuid
    last_name: name
    password: String
    user_name: name
}

"expression to compare columns of type uuid. All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}


scalar bpchar

scalar date

scalar name

scalar numeric

scalar time

scalar uuid